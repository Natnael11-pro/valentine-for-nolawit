    <script>
        // Create floating hearts
        const heartsContainer = document.getElementById('hearts-container');
        for (let i = 0; i < 15; i++) {
            const heart = document.createElement('div');
            heart.classList.add('heart');
            heart.innerHTML = '‚ù§';
            heart.style.left = `${Math.random() * 100}%`;
            heart.style.animationDelay = `${Math.random() * 5}s`;
            heart.style.fontSize = `${Math.random() * 20 + 20}px`;
            heartsContainer.appendChild(heart);
        }
        
        // Get DOM elements
        const yesBtn = document.getElementById('yesBtn');
        const noBtn = document.getElementById('noBtn');
        const responseMessage = document.getElementById('responseMessage');
        const buttonsContainer = document.querySelector('.buttons-container');
        
        // Make NO button impossible to click - IMPROVED VERSION
        let isRunningAway = false;
        let escapeTimeout;
        
        // Function to move NO button to a random safe position
        function escapeToRandomPosition() {
            if (isRunningAway) return;
            
            isRunningAway = true;
            const containerRect = buttonsContainer.getBoundingClientRect();
            
            // Calculate new random position that's far from current position
            const currentX = parseFloat(noBtn.style.left) || 0;
            const currentY = parseFloat(noBtn.style.top) || 0;
            
            let newX, newY;
            let attempts = 0;
            
            // Keep trying until we find a position far enough from current
            do {
                newX = Math.random() * (containerRect.width - 200) + 50;
                newY = Math.random() * (containerRect.height - 80) + 40;
                attempts++;
                
                // If we can't find a good position after 10 tries, just take any
                if (attempts > 10) break;
                
            } while (Math.abs(newX - currentX) < 100 && Math.abs(newY - currentY) < 80);
            
            // Add some random offset to make it more unpredictable
            newX += (Math.random() - 0.5) * 50;
            newY += (Math.random() - 0.5) * 30;
            
            // Ensure it stays within bounds
            newX = Math.max(20, Math.min(containerRect.width - 120, newX));
            newY = Math.max(20, Math.min(containerRect.height - 60, newY));
            
            // Animate the movement
            noBtn.style.transition = 'all 0.3s ease-out';
            noBtn.style.left = `${newX}px`;
            noBtn.style.top = `${newY}px`;
            
            // Reset after movement
            setTimeout(() => {
                isRunningAway = false;
                noBtn.style.transition = 'all 0.2s ease-out';
            }, 300);
        }
        
        // Track cursor proximity and move button BEFORE cursor gets too close
        document.addEventListener('mousemove', (e) => {
            if (isRunningAway) return;
            
            const noBtnRect = noBtn.getBoundingClientRect();
            const containerRect = buttonsContainer.getBoundingClientRect();
            
            // Calculate distance from cursor to button center
            const btnCenterX = noBtnRect.left + noBtnRect.width / 2;
            const btnCenterY = noBtnRect.top + noBtnRect.height / 2;
            const distanceX = e.clientX - btnCenterX;
            const distanceY = e.clientY - btnCenterY;
            const distance = Math.sqrt(distanceX * distanceX + distanceY * distanceY);
            
            // If cursor is getting close (200px), run away!
            if (distance < 200) {
                // Clear any previous timeout
                if (escapeTimeout) clearTimeout(escapeTimeout);
                
                // Run away immediately if very close
                if (distance < 100) {
                    escapeToRandomPosition();
                } else {
                    // If somewhat close, run away after a short delay
                    escapeTimeout = setTimeout(() => {
                        escapeToRandomPosition();
                    }, 200);
                }
                
                // Also push button away from cursor direction
                if (distance < 150) {
                    const pushForce = 1.5;
                    const newX = parseFloat(noBtn.style.left) - (distanceX * pushForce / distance) * 10;
                    const newY = parseFloat(noBtn.style.top) - (distanceY * pushForce / distance) * 10;
                    
                    // Keep within bounds
                    const boundedX = Math.max(20, Math.min(containerRect.width - 120, newX));
                    const boundedY = Math.max(20, Math.min(containerRect.height - 60, newY));
                    
                    noBtn.style.left = `${boundedX}px`;
                    noBtn.style.top = `${boundedY}px`;
                }
            }
        });
        
        // Also run away if cursor touches button area
        noBtn.addEventListener('mouseenter', () => {
            escapeToRandomPosition();
        });
        
        // Run away on touch for mobile devices
        noBtn.addEventListener('touchstart', (e) => {
            e.preventDefault();
            escapeToRandomPosition();
            
            // Also move it extra far for mobile
            setTimeout(escapeToRandomPosition, 100);
        });
        
        // Make button jiggle occasionally to attract attention
        function jiggleButton() {
            if (isRunningAway) return;
            
            const currentX = parseFloat(noBtn.style.left) || 0;
            const currentY = parseFloat(noBtn.style.top) || 0;
            
            // Small random movement
            noBtn.style.transition = 'all 0.1s ease-out';
            noBtn.style.left = `${currentX + (Math.random() - 0.5) * 10}px`;
            noBtn.style.top = `${currentY + (Math.random() - 0.5) * 10}px`;
            
            setTimeout(() => {
                if (!isRunningAway) {
                    noBtn.style.transition = 'all 0.1s ease-out';
                    noBtn.style.left = `${currentX}px`;
                    noBtn.style.top = `${currentY}px`;
                }
            }, 100);
        }
        
        // Jiggle every 3-8 seconds randomly
        setInterval(jiggleButton, 3000 + Math.random() * 5000);
        
        // Handle YES button click
        yesBtn.addEventListener('click', () => {
            responseMessage.style.display = 'block';
            celebrate();
            noBtn.style.display = 'none';
            yesBtn.textContent = "THANK YOU! üíñ";
            yesBtn.style.backgroundColor = "#D81B60";
            yesBtn.style.boxShadow = "0 6px 0 #AD1457";
            yesBtn.disabled = true;
            
            // Stop all button movements
            isRunningAway = true;
        });
        
        // Handle NO button click (virtually impossible now!)
        noBtn.addEventListener('click', () => {
            // Make it even harder by moving immediately
            escapeToRandomPosition();
            
            // Playful message if somehow clicked
            const messages = [
                "Nice try! But I'm too fast! üèÉ‚Äç‚ôÇÔ∏è",
                "Almost! But not quite! üòâ",
                "Too slow! Try again! üê¢",
                "Getting closer... but not close enough! üòÑ",
                "The YES button is looking lonely! üíö"
            ];
            
            const randomMsg = messages[Math.floor(Math.random() * messages.length)];
            
            // Create a temporary message
            const tempMsg = document.createElement('div');
            tempMsg.textContent = randomMsg;
            tempMsg.style.position = 'fixed';
            tempMsg.style.top = '50%';
            tempMsg.style.left = '50%';
            tempMsg.style.transform = 'translate(-50%, -50%)';
            tempMsg.style.background = 'rgba(0,0,0,0.8)';
            tempMsg.style.color = 'white';
            tempMsg.style.padding = '10px 20px';
            tempMsg.style.borderRadius = '10px';
            tempMsg.style.zIndex = '1000';
            tempMsg.style.fontSize = '1.2rem';
            
            document.body.appendChild(tempMsg);
            
            setTimeout(() => {
                tempMsg.remove();
            }, 1500);
            
            // Move button far away again
            setTimeout(escapeToRandomPosition, 300);
        });
        
        // Celebration effect
        function celebrate() {
            for (let i = 0; i < 20; i++) {
                setTimeout(() => {
                    const heart = document.createElement('div');
                    heart.classList.add('heart');
                    heart.innerHTML = '‚ù§';
                    heart.style.left = `${Math.random() * 100}%`;
                    heart.style.animationDelay = '0s';
                    heart.style.fontSize = `${Math.random() * 25 + 25}px`;
                    heart.style.color = i % 2 === 0 ? '#ff4081' : '#d81b60';
                    heartsContainer.appendChild(heart);
                    setTimeout(() => { heart.remove(); }, 5000);
                }, i * 200);
            }
            
            const emojis = ['üéâ', 'üíï', 'ü•∞', 'üíñ', 'üòç', 'üéä'];
            for (let i = 0; i < 15; i++) {
                setTimeout(() => {
                    const emoji = document.createElement('div');
                    emoji.textContent = emojis[Math.floor(Math.random() * emojis.length)];
                    emoji.style.position = 'absolute';
                    emoji.style.fontSize = `${Math.random() * 30 + 30}px`;
                    emoji.style.left = `${Math.random() * 100}%`;
                    emoji.style.top = `${Math.random() * 100}%`;
                    emoji.style.zIndex = '999';
                    emoji.style.pointerEvents = 'none';
                    emoji.style.animation = `float 3s ease-out forwards`;
                    document.querySelector('.container').appendChild(emoji);
                    setTimeout(() => { emoji.remove(); }, 3000);
                }, i * 100);
            }
        }
        
        // Initialize button position
        window.addEventListener('load', () => {
            const containerRect = buttonsContainer.getBoundingClientRect();
            noBtn.style.position = 'absolute';
            
            // Start at random position
            escapeToRandomPosition();
            
            // Also move it once after a second (to surprise user)
            setTimeout(escapeToRandomPosition, 1000);
        });
    </script>
